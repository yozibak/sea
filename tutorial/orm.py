from sqlalchemy.orm import declarative_base, sessionmaker
from sqlalchemy import Column, Integer, String, create_engine

# connect to db
engine = create_engine('sqlite:///:memory:', echo=False)

# declare mappings
Base = declarative_base()

class Todo(Base):
    __tablename__ = 'todos'

    id = Column(Integer, primary_key=True)
    title = Column(String(200))

    def __repr__(self):
        return f"<Todo(title='{self.title}')>"

# Now we have collections of objects like MetaData -> Table -> Column
# Now apply all of it into real
Base.metadata.create_all(engine)

# Create session. We use this to commit or rollback operations on db.
Session = sessionmaker(bind=engine)

session = Session()

# It's still 'pending' and no SQL executed
todo1 = Todo(title='buy coffee beans')
session.add(todo1) 

print(
    session.new # pending
)

# and it executes SQL once we need it, for persistency
todo1 == session.query(Todo).first()

print(
    session.new # no pending
)

# SQLAlchemy knows it's been modified (but no exec immediately)
todo1.title = 'buy coffee roaster'

print(
    session.new,
    session.dirty,
)

# Commit remaining (dirty) operations

# print(session.id) it still fails, since no attr assigned

session.commit()

print(
    session.new,
    session.dirty,
)

# now it has id generated by SQLite

print('todo1.id',todo1.id)

print(session.query(Todo))

# Let's try more...
todo1.title = 'Blah blah blah'

todo_another = Todo(title='myao myao')

session.add(todo_another)

print(
    session.query(Todo).all()
)

# ...Nope
session.rollback()

print(
    session.query(Todo).all()
)

# querying

for instance in session.query(Todo).order_by(Todo.id):
    print(instance.title, instance.id)

for title, id in session.query(Todo.title, Todo.id):
    print(title, id)

